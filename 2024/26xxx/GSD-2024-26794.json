{
  "gsd": {
    "metadata": {
      "exploitCode": "unknown",
      "remediation": "unknown",
      "reportConfidence": "confirmed",
      "type": "vulnerability"
    },
    "osvSchema": {
      "aliases": [
        "CVE-2024-26794"
      ],
      "id": "GSD-2024-26794",
      "modified": "2024-02-20T06:02:29.120634Z",
      "schema_version": "1.4.0"
    }
  },
  "namespaces": {
    "cve.org": {
      "CVE_data_meta": {
        "ASSIGNER": "cve@mitre.org",
        "ID": "CVE-2024-26794",
        "STATE": "RESERVED"
      },
      "data_format": "MITRE",
      "data_type": "CVE",
      "data_version": "4.0",
      "description": {
        "description_data": [
          {
            "lang": "eng",
            "value": "** RESERVED ** This candidate has been reserved by an organization or individual that will use it when announcing a new security problem. When the candidate has been publicized, the details for this candidate will be provided."
          }
        ]
      }
    },
    "nvd.nist.gov": {
      "cve": {
        "descriptions": [
          {
            "lang": "en",
            "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix race between ordered extent completion and fiemap\n\nFor fiemap we recently stopped locking the target extent range for the\nwhole duration of the fiemap call, in order to avoid a deadlock in a\nscenario where the fiemap buffer happens to be a memory mapped range of\nthe same file. This use case is very unlikely to be useful in practice but\nit may be triggered by fuzz testing (syzbot, etc).\n\nHowever by not locking the target extent range for the whole duration of\nthe fiemap call we can race with an ordered extent. This happens like\nthis:\n\n1) The fiemap task finishes processing a file extent item that covers\n   the file range [512K, 1M[, and that file extent item is the last item\n   in the leaf currently being processed;\n\n2) And ordered extent for the file range [768K, 2M[, in COW mode,\n   completes (btrfs_finish_one_ordered()) and the file extent item\n   covering the range [512K, 1M[ is trimmed to cover the range\n   [512K, 768K[ and then a new file extent item for the range [768K, 2M[\n   is inserted in the inode's subvolume tree;\n\n3) The fiemap task calls fiemap_next_leaf_item(), which then calls\n   btrfs_next_leaf() to find the next leaf / item. This finds that the\n   the next key following the one we previously processed (its type is\n   BTRFS_EXTENT_DATA_KEY and its offset is 512K), is the key corresponding\n   to the new file extent item inserted by the ordered extent, which has\n   a type of BTRFS_EXTENT_DATA_KEY and an offset of 768K;\n\n4) Later the fiemap code ends up at emit_fiemap_extent() and triggers\n   the warning:\n\n      if (cache->offset + cache->len > offset) {\n               WARN_ON(1);\n               return -EINVAL;\n      }\n\n   Since we get 1M > 768K, because the previously emitted entry for the\n   old extent covering the file range [512K, 1M[ ends at an offset that\n   is greater than the new extent's start offset (768K). This makes fiemap\n   fail with -EINVAL besides triggering the warning that produces a stack\n   trace like the following:\n\n     [1621.677651] ------------[ cut here ]------------\n     [1621.677656] WARNING: CPU: 1 PID: 204366 at fs/btrfs/extent_io.c:2492 emit_fiemap_extent+0x84/0x90 [btrfs]\n     [1621.677899] Modules linked in: btrfs blake2b_generic (...)\n     [1621.677951] CPU: 1 PID: 204366 Comm: pool Not tainted 6.8.0-rc5-btrfs-next-151+ #1\n     [1621.677954] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014\n     [1621.677956] RIP: 0010:emit_fiemap_extent+0x84/0x90 [btrfs]\n     [1621.678033] Code: 2b 4c 89 63 (...)\n     [1621.678035] RSP: 0018:ffffab16089ffd20 EFLAGS: 00010206\n     [1621.678037] RAX: 00000000004fa000 RBX: ffffab16089ffe08 RCX: 0000000000009000\n     [1621.678039] RDX: 00000000004f9000 RSI: 00000000004f1000 RDI: ffffab16089ffe90\n     [1621.678040] RBP: 00000000004f9000 R08: 0000000000001000 R09: 0000000000000000\n     [1621.678041] R10: 0000000000000000 R11: 0000000000001000 R12: 0000000041d78000\n     [1621.678043] R13: 0000000000001000 R14: 0000000000000000 R15: ffff9434f0b17850\n     [1621.678044] FS:  00007fa6e20006c0(0000) GS:ffff943bdfa40000(0000) knlGS:0000000000000000\n     [1621.678046] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n     [1621.678048] CR2: 00007fa6b0801000 CR3: 000000012d404002 CR4: 0000000000370ef0\n     [1621.678053] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n     [1621.678055] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n     [1621.678056] Call Trace:\n     [1621.678074]  <TASK>\n     [1621.678076]  ? __warn+0x80/0x130\n     [1621.678082]  ? emit_fiemap_extent+0x84/0x90 [btrfs]\n     [1621.678159]  ? report_bug+0x1f4/0x200\n     [1621.678164]  ? handle_bug+0x42/0x70\n     [1621.678167]  ? exc_invalid_op+0x14/0x70\n     [1621.678170]  ? asm_exc_invalid_op+0x16/0x20\n     [1621.678178]  ? emit_fiemap_extent+0x84/0x90 [btrfs]\n     [1621.678253]  extent_fiemap+0x766\n---truncated---"
          },
          {
            "lang": "es",
            "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs: corrige la ejecuci\u00f3n entre la finalizaci\u00f3n de extensi\u00f3n ordenada y fiemap Para fiemap recientemente dejamos de bloquear el rango de extensi\u00f3n objetivo durante toda la duraci\u00f3n de la llamada a fiemap, para evitar un punto muerto en un escenario donde el b\u00fafer fiemap resulta ser un rango mapeado en memoria del mismo archivo. Es muy poco probable que este caso de uso sea \u00fatil en la pr\u00e1ctica, pero puede activarse mediante pruebas difusas (syzbot, etc.). Sin embargo, al no bloquear el rango de extensi\u00f3n objetivo durante toda la duraci\u00f3n de la llamada a fiemap, podemos competir con una extensi\u00f3n ordenada. Esto sucede as\u00ed: 1) La tarea fiemap termina de procesar un elemento de extensi\u00f3n de archivo que cubre el rango de archivos [512K, 1M[, y ese elemento de extensi\u00f3n de archivo es el \u00faltimo elemento de la hoja que se est\u00e1 procesando actualmente; 2) Y la extensi\u00f3n ordenada para el rango de archivos [768K, 2M[, en modo COW, se completa (btrfs_finish_one_ordered()) y el elemento de extensi\u00f3n de archivo que cubre el rango [512K, 1M[ se recorta para cubrir el rango [512K, 768K[ y luego se inserta un nuevo elemento de extensi\u00f3n de archivo para el rango [768K, 2M[ en el \u00e1rbol de subvolumen del inodo; 3) La tarea fiemap llama a fiemap_next_leaf_item(), que luego llama a btrfs_next_leaf() para encontrar la siguiente hoja/elemento. Esto encuentra que la siguiente clave despu\u00e9s de la que procesamos anteriormente (su tipo es BTRFS_EXTENT_DATA_KEY y su desplazamiento es 512K), es la clave correspondiente al nuevo elemento de extensi\u00f3n de archivo insertado por la extensi\u00f3n ordenada, que tiene un tipo de BTRFS_EXTENT_DATA_KEY y un desplazamiento de 768K; 4) M\u00e1s tarde, el c\u00f3digo fiemap termina en emit_fiemap_extent() y activa la advertencia: if (cache-&gt;offset + cache-&gt;len &gt; offset) { WARN_ON(1); devolver -EINVAL; } Dado que obtenemos 1M &gt; 768K, porque la entrada emitida previamente para la extensi\u00f3n anterior que cubre el rango de archivos [512K, 1M[ termina en un desplazamiento que es mayor que el desplazamiento inicial de la nueva extensi\u00f3n (768K). Esto hace que fiemap falle con -EINVAL adem\u00e1s de activar la advertencia que produce un seguimiento de pila como el siguiente: [1621.677651] ------------[ cortar aqu\u00ed ]----------- - [1621.677656] ADVERTENCIA: CPU: 1 PID: 204366 en fs/btrfs/extent_io.c:2492 emit_fiemap_extent+0x84/0x90 [btrfs] [1621.677899] M\u00f3dulos vinculados en: btrfs blake2b_generic (...) [1621.677951] CPU: 1 PID: 204366 Comm: pool No contaminado 6.8.0-rc5-btrfs-next-151+ #1 [1621.677954] Nombre del hardware: PC est\u00e1ndar QEMU (i440FX + PIIX, 1996), BIOS rel-1.16.2-0-gea1b7a073390- prebuilt.qemu.org 01/04/2014 [1621.677956] RIP: 0010:emit_fiemap_extent+0x84/0x90 [btrfs] [1621.678033] C\u00f3digo: 2b 4c 89 63 (...) [1621.678035] RSP: 0018:ffffab160 89ffd20 EFLAGS: 00010206 [1621.678037] RAX: 00000000004fa000 RBX: ffffab16089ffe08 RCX: 0000000000009000 [1621.678039] RDX: 00000000004f9000 RSI: 00000000004f1000 RDI : ffffab16089ffe90 [1621.678040] RBP: 00000000004f9000 R08: 0000000000001000 R09: 00000000000000000 [1621.678041] R10: 0000000000000000 R11 : 0000000000001000 R12: 0000000041d78000 [1621.678043 ] R13: 0000000000001000 R14: 00000000000000000 R15: ffff9434f0b17850 [1621.678044] FS: 00007fa6e20006c0(0000) GS:ffff943bdfa40000(0000) kn lGS:0000000000000000 [1621.678046] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [1621.678048] CR2: 00007fa6b0801000 CR3 : 000000012d404002 CR4: 0000000000370ef0 [1621.678053] DR0: 0000000000000000 DR1: 00000000000000000 DR2: 0000000000000000 [1621.678055] DR 3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [1621.678056] Seguimiento de llamadas: [1621.678074]  [1621.678076] ? __advertir+0x80/0x130 [1621.678082] ? emit_fiemap_extent+0x84/0x90 [btrfs] [1621.678159] ? report_bug+0x1f4/0x200 [1621.678164] ? ---truncado---"
          }
        ],
        "id": "CVE-2024-26794",
        "lastModified": "2024-04-04T14:15:09.843",
        "metrics": {},
        "published": "2024-04-04T09:15:08.683",
        "references": [
          {
            "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
            "url": "https://git.kernel.org/stable/c/31d07a757c6d3430e03cc22799921569999b9a12"
          },
          {
            "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
            "url": "https://git.kernel.org/stable/c/a1a4a9ca77f143c00fce69c1239887ff8b813bec"
          },
          {
            "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
            "url": "https://git.kernel.org/stable/c/d43f8e58f10a44df8c08e7f7076f3288352cd168"
          }
        ],
        "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
        "vulnStatus": "Awaiting Analysis"
      }
    }
  }
}